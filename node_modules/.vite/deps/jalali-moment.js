import {
  require_moment
} from "./chunk-GDNBYF4A.js";
import {
  __commonJS,
  __require,
  init_buffer,
  init_process
} from "./chunk-LYUL3WXY.js";

// node_modules/moment/locale/fa.js
var require_fa = __commonJS({
  "node_modules/moment/locale/fa.js"(exports, module) {
    init_process();
    init_buffer();
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" && typeof __require === "function" ? factory(require_moment()) : typeof define === "function" && define.amd ? define(["../moment"], factory) : factory(global.moment);
    })(exports, function(moment) {
      "use strict";
      var symbolMap = {
        1: "۱",
        2: "۲",
        3: "۳",
        4: "۴",
        5: "۵",
        6: "۶",
        7: "۷",
        8: "۸",
        9: "۹",
        0: "۰"
      }, numberMap = {
        "۱": "1",
        "۲": "2",
        "۳": "3",
        "۴": "4",
        "۵": "5",
        "۶": "6",
        "۷": "7",
        "۸": "8",
        "۹": "9",
        "۰": "0"
      };
      var fa = moment.defineLocale("fa", {
        months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split(
          "_"
        ),
        monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split(
          "_"
        ),
        weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split(
          "_"
        ),
        weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split(
          "_"
        ),
        weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "DD/MM/YYYY",
          LL: "D MMMM YYYY",
          LLL: "D MMMM YYYY HH:mm",
          LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function(input) {
          return /بعد از ظهر/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
          if (hour < 12) {
            return "قبل از ظهر";
          } else {
            return "بعد از ظهر";
          }
        },
        calendar: {
          sameDay: "[امروز ساعت] LT",
          nextDay: "[فردا ساعت] LT",
          nextWeek: "dddd [ساعت] LT",
          lastDay: "[دیروز ساعت] LT",
          lastWeek: "dddd [پیش] [ساعت] LT",
          sameElse: "L"
        },
        relativeTime: {
          future: "در %s",
          past: "%s پیش",
          s: "چند ثانیه",
          ss: "%d ثانیه",
          m: "یک دقیقه",
          mm: "%d دقیقه",
          h: "یک ساعت",
          hh: "%d ساعت",
          d: "یک روز",
          dd: "%d روز",
          M: "یک ماه",
          MM: "%d ماه",
          y: "یک سال",
          yy: "%d سال"
        },
        preparse: function(string) {
          return string.replace(/[۰-۹]/g, function(match) {
            return numberMap[match];
          }).replace(/،/g, ",");
        },
        postformat: function(string) {
          return string.replace(/\d/g, function(match) {
            return symbolMap[match];
          }).replace(/,/g, "،");
        },
        dayOfMonthOrdinalParse: /\d{1,2}م/,
        ordinal: "%dم",
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12
          // The week that contains Jan 12th is the first week of the year.
        }
      });
      return fa;
    });
  }
});

// node_modules/jalali-moment/jalali-moment.js
var require_jalali_moment = __commonJS({
  "node_modules/jalali-moment/jalali-moment.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = jMoment;
    var moment = require_moment();
    require_fa();
    var formattingTokens = /(\[[^\[]*\])|(\\)?j(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?|)|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g;
    var parseTokenOneOrTwoDigits = /\d\d?/;
    var parseTokenOneToThreeDigits = /\d{1,3}/;
    var parseTokenThreeDigits = /\d{3}/;
    var parseTokenFourDigits = /\d{1,4}/;
    var parseTokenSixDigits = /[+\-]?\d{1,6}/;
    var parseTokenWord = /[0-9]*["a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i;
    var parseTokenT = /T/i;
    var parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/;
    var unitAliases = {
      jm: "jmonth",
      jmonths: "jmonth",
      jy: "jyear",
      jyears: "jyear"
    };
    var formatFunctions = {};
    var ordinalizeTokens = "DDD w M D".split(" ");
    var paddedTokens = "M D w".split(" ");
    var CalendarSystems = {
      Jalali: 1,
      Gregorian: 2
    };
    var formatTokenFunctions = {
      jM: function() {
        return this.jMonth() + 1;
      },
      jMMM: function(format) {
        return this.localeData().jMonthsShort(this, format);
      },
      jMMMM: function(format) {
        return this.localeData().jMonths(this, format);
      },
      jD: function() {
        return this.jDate();
      },
      jDDD: function() {
        return this.jDayOfYear();
      },
      jw: function() {
        return this.jWeek();
      },
      jYY: function() {
        return leftZeroFill(this.jYear() % 100, 2);
      },
      jYYYY: function() {
        return leftZeroFill(this.jYear(), 4);
      },
      jYYYYY: function() {
        return leftZeroFill(this.jYear(), 5);
      },
      jgg: function() {
        return leftZeroFill(this.jWeekYear() % 100, 2);
      },
      jgggg: function() {
        return this.jWeekYear();
      },
      jggggg: function() {
        return leftZeroFill(this.jWeekYear(), 5);
      }
    };
    function padToken(func, count) {
      return function(a) {
        return leftZeroFill(func.call(this, a), count);
      };
    }
    function ordinalizeToken(func, period) {
      return function(a) {
        return this.localeData().ordinal(func.call(this, a), period);
      };
    }
    (function() {
      var i;
      while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions["j" + i + "o"] = ordinalizeToken(formatTokenFunctions["j" + i], i);
      }
      while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions["j" + i + i] = padToken(formatTokenFunctions["j" + i], 2);
      }
      formatTokenFunctions.jDDDD = padToken(formatTokenFunctions.jDDD, 3);
    })();
    function extend(a, b) {
      var key;
      for (key in b)
        if (b.hasOwnProperty(key)) {
          a[key] = b[key];
        }
      return a;
    }
    function leftZeroFill(number, targetLength) {
      var output = number + "";
      while (output.length < targetLength) {
        output = "0" + output;
      }
      return output;
    }
    function isArray(input) {
      return Object.prototype.toString.call(input) === "[object Array]";
    }
    function toJalaliFormat(format) {
      for (var i = 0; i < format.length; i++) {
        if (!i || format[i - 1] !== "j" && format[i - 1] !== format[i]) {
          if (format[i] === "Y" || format[i] === "M" || format[i] === "D" || format[i] === "g") {
            format = format.slice(0, i) + "j" + format.slice(i);
          }
        }
      }
      return format;
    }
    function toJalaliUnit(units) {
      switch (units) {
        case "week":
          return "jWeek";
        case "year":
          return "jYear";
        case "month":
          return "jMonth";
        case "months":
          return "jMonths";
        case "monthName":
          return "jMonthsShort";
        case "monthsShort":
          return "jMonthsShort";
      }
      return units;
    }
    function normalizeUnits(units, momentObj) {
      if (isJalali(momentObj)) {
        units = toJalaliUnit(units);
      }
      if (units) {
        var lowered = units.toLowerCase();
        if (lowered.startsWith("j")) units = unitAliases[lowered] || lowered;
        if (units === "jday") units = "day";
        else if (units === "jd") units = "d";
      }
      return units;
    }
    function setDate(momentInstance, year, month, day) {
      var d = momentInstance._d;
      if (momentInstance._isUTC) {
        momentInstance._d = new Date(Date.UTC(
          year,
          month,
          day,
          d.getUTCHours(),
          d.getUTCMinutes(),
          d.getUTCSeconds(),
          d.getUTCMilliseconds()
        ));
      } else {
        momentInstance._d = new Date(
          year,
          month,
          day,
          d.getHours(),
          d.getMinutes(),
          d.getSeconds(),
          d.getMilliseconds()
        );
      }
    }
    function objectCreate(parent) {
      function F() {
      }
      F.prototype = parent;
      return new F();
    }
    function getPrototypeOf(object) {
      if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(object);
      } else if ("".__proto__) {
        return object.__proto__;
      } else {
        return object.constructor.prototype;
      }
    }
    extend(
      getPrototypeOf(moment.localeData()),
      {
        _jMonths: [
          "Farvardin",
          "Ordibehesht",
          "Khordaad",
          "Tir",
          "Mordaad",
          "Shahrivar",
          "Mehr",
          "Aabaan",
          "Aazar",
          "Dey",
          "Bahman",
          "Esfand"
        ],
        jMonths: function(m) {
          if (m) {
            return this._jMonths[m.jMonth()];
          } else {
            return this._jMonths;
          }
        },
        _jMonthsShort: [
          "Far",
          "Ord",
          "Kho",
          "Tir",
          "Amo",
          "Sha",
          "Meh",
          "Aab",
          "Aaz",
          "Dey",
          "Bah",
          "Esf"
        ],
        jMonthsShort: function(m) {
          if (m) {
            return this._jMonthsShort[m.jMonth()];
          } else {
            return this._jMonthsShort;
          }
        },
        jMonthsParse: function(monthName) {
          var i, mom, regex;
          if (!this._jMonthsParse) {
            this._jMonthsParse = [];
          }
          for (i = 0; i < 12; i += 1) {
            if (!this._jMonthsParse[i]) {
              mom = jMoment([2e3, (2 + i) % 12, 25]);
              regex = "^" + this.jMonths(mom, "") + "|^" + this.jMonthsShort(mom, "");
              this._jMonthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (this._jMonthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
      }
    );
    function makeFormatFunction(format) {
      var array = format.match(formattingTokens), length = array.length, i;
      for (i = 0; i < length; i += 1) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        }
      }
      return function(mom) {
        var output = "";
        for (i = 0; i < length; i += 1) {
          output += array[i] instanceof Function ? "[" + array[i].call(mom, format) + "]" : array[i];
        }
        return output;
      };
    }
    function getParseRegexForToken(token, config) {
      switch (token) {
        case "jDDDD":
          return parseTokenThreeDigits;
        case "jYYYY":
          return parseTokenFourDigits;
        case "jYYYYY":
          return parseTokenSixDigits;
        case "jDDD":
          return parseTokenOneToThreeDigits;
        case "jMMM":
        case "jMMMM":
          return parseTokenWord;
        case "jMM":
        case "jDD":
        case "jYY":
        case "jM":
        case "jD":
          return parseTokenOneOrTwoDigits;
        case "DDDD":
          return parseTokenThreeDigits;
        case "YYYY":
          return parseTokenFourDigits;
        case "YYYYY":
          return parseTokenSixDigits;
        case "S":
        case "SS":
        case "SSS":
        case "DDD":
          return parseTokenOneToThreeDigits;
        case "MMM":
        case "MMMM":
        case "dd":
        case "ddd":
        case "dddd":
          return parseTokenWord;
        case "a":
        case "A":
          return moment.localeData(config._l)._meridiemParse;
        case "X":
          return parseTokenTimestampMs;
        case "Z":
        case "ZZ":
          return parseTokenTimezone;
        case "T":
          return parseTokenT;
        case "MM":
        case "DD":
        case "YY":
        case "HH":
        case "hh":
        case "mm":
        case "ss":
        case "M":
        case "D":
        case "d":
        case "H":
        case "h":
        case "m":
        case "s":
          return parseTokenOneOrTwoDigits;
        default:
          return new RegExp(token.replace("\\", ""));
      }
    }
    function isNull(variable) {
      return variable === null || variable === void 0;
    }
    function addTimeToArrayFromToken(token, input, config) {
      var a, datePartArray = config._a;
      switch (token) {
        case "jM":
        case "jMM":
          datePartArray[1] = isNull(input) ? 0 : ~~input - 1;
          break;
        case "jMMM":
        case "jMMMM":
          a = moment.localeData(config._l).jMonthsParse(input);
          if (!isNull(a)) {
            datePartArray[1] = a;
          } else {
            config._isValid = false;
          }
          break;
        case "jD":
        case "jDD":
        case "jDDD":
        case "jDDDD":
          if (!isNull(input)) {
            datePartArray[2] = ~~input;
          }
          break;
        case "jYY":
          datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400);
          break;
        case "jYYYY":
        case "jYYYYY":
          datePartArray[0] = ~~input;
      }
      if (isNull(input)) {
        config._isValid = false;
      }
    }
    function dateFromArray(config) {
      var g, j, jy = config._a[0], jm = config._a[1], jd = config._a[2];
      if (isNull(jy) && isNull(jm) && isNull(jd)) {
        return;
      }
      jy = !isNull(jy) ? jy : 0;
      jm = !isNull(jm) ? jm : 0;
      jd = !isNull(jd) ? jd : 1;
      if (jd < 1 || jd > jMoment.jDaysInMonth(jy, jm) || jm < 0 || jm > 11) {
        config._isValid = false;
      }
      g = toGregorian(jy, jm, jd);
      j = toJalali(g.gy, g.gm, g.gd);
      config._jDiff = 0;
      if (~~j.jy !== jy) {
        config._jDiff += 1;
      }
      if (~~j.jm !== jm) {
        config._jDiff += 1;
      }
      if (~~j.jd !== jd) {
        config._jDiff += 1;
      }
      return [g.gy, g.gm, g.gd];
    }
    function makeDateFromStringAndFormat(config) {
      var tokens = config._f.match(formattingTokens), string = config._i + "", len = tokens.length, i, token, parsedInput;
      config._a = [];
      for (i = 0; i < len; i += 1) {
        token = tokens[i];
        parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
        if (parsedInput) {
          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        }
        if (formatTokenFunctions[token]) {
          addTimeToArrayFromToken(token, parsedInput, config);
        }
      }
      if (string) {
        config._il = string;
      }
      return dateFromArray(config);
    }
    function makeDateFromStringAndArray(config, utc) {
      var len = config._f.length, i, format, tempMoment, bestMoment, currentScore, scoreToBeat;
      if (len === 0) {
        return makeMoment(/* @__PURE__ */ new Date(NaN));
      }
      for (i = 0; i < len; i += 1) {
        format = config._f[i];
        currentScore = 0;
        tempMoment = makeMoment(config._i, format, config._l, config._strict, utc);
        if (!tempMoment.isValid()) {
          continue;
        }
        currentScore += tempMoment._jDiff;
        if (tempMoment._il) {
          currentScore += tempMoment._il.length;
        }
        if (isNull(scoreToBeat) || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempMoment;
        }
      }
      return bestMoment;
    }
    function removeParsedTokens(config) {
      var string = config._i + "", input = "", format = "", array = config._f.match(formattingTokens), len = array.length, i, match, parsed;
      for (i = 0; i < len; i += 1) {
        match = array[i];
        parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];
        if (parsed) {
          string = string.slice(string.indexOf(parsed) + parsed.length);
        }
        if (!(formatTokenFunctions[match] instanceof Function)) {
          format += match;
          if (parsed) {
            input += parsed;
          }
        }
      }
      config._i = input;
      config._f = format;
    }
    function jWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
      var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
      if (daysToDayOfWeek > end) {
        daysToDayOfWeek -= 7;
      }
      if (daysToDayOfWeek < end - 7) {
        daysToDayOfWeek += 7;
      }
      adjustedMoment = jMoment(mom).add(daysToDayOfWeek, "d");
      return {
        week: Math.ceil(adjustedMoment.jDayOfYear() / 7),
        year: adjustedMoment.jYear()
      };
    }
    function isJalali(momentObj) {
      return momentObj && momentObj.calSystem === CalendarSystems.Jalali || moment.justUseJalali && momentObj.calSystem !== CalendarSystems.Gregorian;
    }
    function isInputJalali(format, momentObj, input) {
      return moment.justUseJalali || momentObj && momentObj.calSystem === CalendarSystems.Jalali;
    }
    function makeMoment(input, format, lang, strict, utc) {
      if (typeof lang === "boolean") {
        utc = utc || strict;
        strict = lang;
        lang = void 0;
      }
      if (moment.ISO_8601 === format) {
        format = "YYYY-MM-DDTHH:mm:ss.SSSZ";
      }
      const inputIsJalali = isInputJalali(format, this, input);
      if (input && typeof input === "string" && !format && inputIsJalali && !moment.useGregorianParser) {
        input = input.replace(/\//g, "-");
        if (/\d{4}\-\d{2}\-\d{2}/.test(input)) {
          format = "jYYYY-jMM-jDD";
        } else if (/\d{4}\-\d{2}\-\d{1}/.test(input)) {
          format = "jYYYY-jMM-jD";
        } else if (/\d{4}\-\d{1}\-\d{1}/.test(input)) {
          format = "jYYYY-jM-jD";
        } else if (/\d{4}\-\d{1}\-\d{2}/.test(input)) {
          format = "jYYYY-jM-jDD";
        } else if (/\d{4}\-W\d{2}\-\d{2}/.test(input)) {
          format = "jYYYY-jW-jDD";
        } else if (/\d{4}\-\d{3}/.test(input)) {
          format = "jYYYY-jDDD";
        } else if (/\d{8}/.test(input)) {
          format = "jYYYYjMMjDD";
        } else if (/\d{4}W\d{2}\d{1}/.test(input)) {
          format = "jYYYYjWWjD";
        } else if (/\d{4}W\d{2}/.test(input)) {
          format = "jYYYYjWW";
        } else if (/\d{4}\d{3}/.test(input)) {
          format = "jYYYYjDDD";
        }
      }
      if (format && inputIsJalali) {
        format = toJalaliFormat(format);
      }
      if (format && typeof format === "string") {
        format = fixFormat(format, moment);
      }
      var config = {
        _i: input,
        _f: format,
        _l: lang,
        _strict: strict,
        _isUTC: utc
      }, date, m, jm, origInput = input, origFormat = format;
      if (format) {
        if (isArray(format)) {
          return makeDateFromStringAndArray(config, utc);
        } else {
          date = makeDateFromStringAndFormat(config);
          removeParsedTokens(config);
          if (date) {
            format = "YYYY-MM-DD-" + config._f;
            input = leftZeroFill(date[0], 4) + "-" + leftZeroFill(date[1] + 1, 2) + "-" + leftZeroFill(date[2], 2) + "-" + config._i;
          }
        }
      }
      if (utc) {
        m = moment.utc(input, format, lang, strict);
      } else {
        m = moment(input, format, lang, strict);
      }
      if (config._isValid === false || input && input._isAMomentObject && !input._isValid) {
        m._isValid = false;
      }
      m._jDiff = config._jDiff || 0;
      jm = objectCreate(jMoment.fn);
      extend(jm, m);
      if (strict && jm.isValid()) {
        jm._isValid = jm.format(origFormat) === origInput;
      }
      if (input && input.calSystem) {
        jm.calSystem = input.calSystem;
      }
      return jm;
    }
    function jMoment(input, format, lang, strict) {
      return makeMoment(input, format, lang, strict, false);
    }
    extend(jMoment, moment);
    jMoment.fn = objectCreate(moment.fn);
    jMoment.utc = function(input, format, lang, strict) {
      return makeMoment(input, format, lang, strict, true);
    };
    jMoment.unix = function(input) {
      return makeMoment(input * 1e3);
    };
    function fixFormat(format, _moment) {
      var i = 5;
      var replace = function(input) {
        return _moment.localeData().longDateFormat(input) || input;
      };
      while (i > 0 && localFormattingTokens.test(format)) {
        i -= 1;
        format = format.replace(localFormattingTokens, replace);
      }
      return format;
    }
    jMoment.fn.format = function(format) {
      format = format || jMoment.defaultFormat;
      if (format) {
        if (isJalali(this)) {
          format = toJalaliFormat(format);
        }
        format = fixFormat(format, this);
        if (!formatFunctions[format]) {
          formatFunctions[format] = makeFormatFunction(format);
        }
        format = formatFunctions[format](this);
      }
      var formatted = moment.fn.format.call(this, format);
      return formatted;
    };
    jMoment.fn.year = function(input) {
      if (isJalali(this)) return jMoment.fn.jYear.call(this, input);
      else return moment.fn.year.call(this, input);
    };
    jMoment.fn.jYear = function(input) {
      var lastDay, j, g;
      if (typeof input === "number") {
        j = getJalaliOf(this);
        lastDay = Math.min(j.jd, jMoment.jDaysInMonth(input, j.jm));
        g = toGregorian(input, j.jm, lastDay);
        setDate(this, g.gy, g.gm, g.gd);
        moment.updateOffset(this);
        return this;
      } else {
        return getJalaliOf(this).jy;
      }
    };
    jMoment.fn.month = function(input) {
      if (isJalali(this)) return jMoment.fn.jMonth.call(this, input);
      else return moment.fn.month.call(this, input);
    };
    jMoment.fn.jMonth = function(input) {
      var lastDay, j, g;
      if (!isNull(input)) {
        if (typeof input === "string") {
          input = this.localeData().jMonthsParse(input);
          if (typeof input !== "number") {
            return this;
          }
        }
        j = getJalaliOf(this);
        lastDay = Math.min(j.jd, jMoment.jDaysInMonth(j.jy, input));
        this.jYear(j.jy + div(input, 12));
        input = mod(input, 12);
        if (input < 0) {
          input += 12;
          this.jYear(this.jYear() - 1);
        }
        g = toGregorian(this.jYear(), input, lastDay);
        setDate(this, g.gy, g.gm, g.gd);
        moment.updateOffset(this);
        return this;
      } else {
        return getJalaliOf(this).jm;
      }
    };
    jMoment.fn.date = function(input) {
      if (isJalali(this)) return jMoment.fn.jDate.call(this, input);
      else return moment.fn.date.call(this, input);
    };
    function getJalaliOf(momentObj) {
      var d = momentObj._d;
      if (momentObj._isUTC) {
        return toJalali(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
      } else {
        return toJalali(d.getFullYear(), d.getMonth(), d.getDate());
      }
    }
    jMoment.fn.jDate = function(input) {
      var j, g;
      if (typeof input === "number") {
        j = getJalaliOf(this);
        g = toGregorian(j.jy, j.jm, input);
        setDate(this, g.gy, g.gm, g.gd);
        moment.updateOffset(this);
        return this;
      } else {
        return getJalaliOf(this).jd;
      }
    };
    jMoment.fn.jDay = function(input) {
      if (typeof input === "number") {
        return moment.fn.day.call(this, input - 1);
      } else {
        return (moment.fn.day.call(this) + 1) % 7;
      }
    };
    jMoment.fn.diff = function(input, unitOfTime, asFloat) {
      if (!isJalali(this))
        return moment.fn.diff.call(this, input, unitOfTime, asFloat);
      var output;
      switch (unitOfTime) {
        case "year":
          output = monthDiff(this, input) / 12;
          break;
        case "month":
          output = monthDiff(this, input);
          break;
        case "quarter":
          output = monthDiff(this, input) / 3;
          break;
        default:
          output = moment.fn.diff.call(this, input, unitOfTime, asFloat);
      }
      return asFloat ? output : output < 0 ? Math.ceil(output) || 0 : Math.floor(output);
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.jYear() - a.jYear()) * 12 + (b.jMonth() - a.jMonth()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
    };
    jMoment.fn.dayOfYear = function(input) {
      if (isJalali(this)) return jMoment.fn.jDayOfYear.call(this, input);
      else return moment.fn.dayOfYear.call(this, input);
    };
    jMoment.fn.jDayOfYear = function(input) {
      var dayOfYear = Math.round((jMoment(this).startOf("day") - jMoment(this).startOf("jYear")) / 864e5) + 1;
      return isNull(input) ? dayOfYear : this.add(input - dayOfYear, "d");
    };
    jMoment.fn.week = function(input) {
      if (isJalali(this)) return jMoment.fn.jWeek.call(this, input);
      else return moment.fn.week.call(this, input);
    };
    jMoment.fn.jWeek = function(input) {
      var week = jWeekOfYear(this, 6, 12).week;
      return isNull(input) ? week : this.add((input - week) * 7, "d");
    };
    jMoment.fn.weekYear = function(input) {
      if (isJalali(this)) return jMoment.fn.jWeekYear.call(this, input);
      else return moment.fn.weekYear.call(this, input);
    };
    jMoment.fn.jWeekYear = function(input) {
      var year = jWeekOfYear(this, 6, 12).year;
      return isNull(input) ? year : this.add(input - year, "jyear");
    };
    jMoment.fn.add = function(val, units) {
      var temp;
      if (!isNull(units) && !isNaN(+units)) {
        temp = val;
        val = units;
        units = temp;
      }
      units = normalizeUnits(units, this);
      if (units === "jweek" || units === "isoweek") {
        units = "week";
      }
      if (units === "jyear") {
        this.jYear(this.jYear() + val);
      } else if (units === "jmonth") {
        this.jMonth(this.jMonth() + val);
      } else {
        moment.fn.add.call(this, val, units);
      }
      return this;
    };
    jMoment.fn.subtract = function(val, units) {
      var temp;
      if (!isNull(units) && !isNaN(+units)) {
        temp = val;
        val = units;
        units = temp;
      }
      units = normalizeUnits(units, this);
      if (units === "jyear") {
        this.jYear(this.jYear() - val);
      } else if (units === "jmonth") {
        this.jMonth(this.jMonth() - val);
      } else {
        moment.fn.subtract.call(this, val, units);
      }
      return this;
    };
    jMoment.fn.startOf = function(units) {
      var nunit = normalizeUnits(units, this);
      if (nunit === "jweek") {
        return this.startOf("day").subtract(this.jDay(), "day");
      }
      if (nunit === "jyear") {
        this.jMonth(0);
        nunit = "jmonth";
      }
      if (nunit === "jmonth") {
        this.jDate(1);
        nunit = "day";
      }
      if (nunit === "day") {
        this.hours(0);
        this.minutes(0);
        this.seconds(0);
        this.milliseconds(0);
        return this;
      } else {
        return moment.fn.startOf.call(this, units);
      }
    };
    jMoment.fn.endOf = function(units) {
      units = normalizeUnits(units, this);
      if (units === void 0 || units === "milisecond") {
        return this;
      }
      return this.startOf(units).add(1, units).subtract(1, "ms");
    };
    jMoment.fn.isSame = function(other, units) {
      units = normalizeUnits(units, this);
      if (units === "jyear" || units === "jmonth") {
        return moment.fn.isSame.call(this.clone().startOf(units), other.clone().startOf(units));
      }
      return moment.fn.isSame.call(this, other, units);
    };
    jMoment.fn.isBefore = function(other, units) {
      units = normalizeUnits(units, this);
      if (units === "jyear" || units === "jmonth") {
        return moment.fn.isBefore.call(this.clone().startOf(units), other.clone().startOf(units));
      }
      return moment.fn.isBefore.call(this, other, units);
    };
    jMoment.fn.isAfter = function(other, units) {
      units = normalizeUnits(units, this);
      if (units === "jyear" || units === "jmonth") {
        return moment.fn.isAfter.call(this.clone().startOf(units), other.clone().startOf(units));
      }
      return moment.fn.isAfter.call(this, other, units);
    };
    jMoment.fn.clone = function() {
      return jMoment(this);
    };
    jMoment.fn.doAsJalali = function() {
      this.calSystem = CalendarSystems.Jalali;
      return this;
    };
    jMoment.fn.doAsGregorian = function() {
      this.calSystem = CalendarSystems.Gregorian;
      return this;
    };
    jMoment.fn.jYears = jMoment.fn.jYear;
    jMoment.fn.jMonths = jMoment.fn.jMonth;
    jMoment.fn.jDates = jMoment.fn.jDate;
    jMoment.fn.jWeeks = jMoment.fn.jWeek;
    jMoment.fn.daysInMonth = function() {
      if (isJalali(this)) {
        return this.jDaysInMonth();
      }
      return moment.fn.daysInMonth.call(this);
    };
    jMoment.fn.jDaysInMonth = function() {
      var month = this.jMonth();
      var year = this.jYear();
      if (month < 6) {
        return 31;
      } else if (month < 11) {
        return 30;
      } else if (jMoment.jIsLeapYear(year)) {
        return 30;
      } else {
        return 29;
      }
    };
    jMoment.fn.isLeapYear = function() {
      if (isJalali(this)) {
        return this.jIsLeapYear();
      }
      return moment.fn.isLeapYear.call(this);
    };
    jMoment.fn.jIsLeapYear = function() {
      var year = this.jYear();
      return isLeapJalaliYear(year);
    };
    jMoment.fn.locale = function(locale) {
      if (locale && moment.changeCalendarSystemByItsLocale) {
        if (locale === "fa") {
          this.doAsJalali();
        } else {
          this.doAsGregorian();
        }
      }
      return moment.fn.locale.call(this, locale);
    };
    jMoment.locale = function(locale, options) {
      if (locale && moment.changeCalendarSystemByItsLocale) {
        if (locale === "fa") {
          this.useJalaliSystemPrimarily(options);
        } else {
          this.useJalaliSystemSecondary();
        }
      }
      return moment.locale.call(this, locale);
    };
    jMoment.from = function(date, locale, format) {
      var lastLocale = jMoment.locale();
      jMoment.locale(locale);
      var m = jMoment(date, format);
      m.locale(lastLocale);
      jMoment.locale(lastLocale);
      return m;
    };
    jMoment.bindCalendarSystemAndLocale = function() {
      moment.changeCalendarSystemByItsLocale = true;
    };
    jMoment.unBindCalendarSystemAndLocale = function() {
      moment.changeCalendarSystemByItsLocale = false;
    };
    jMoment.useJalaliSystemPrimarily = function(options) {
      moment.justUseJalali = true;
      var useGregorianParser = false;
      if (options) {
        useGregorianParser = options.useGregorianParser;
      }
      moment.useGregorianParser = useGregorianParser;
    };
    jMoment.useJalaliSystemSecondary = function() {
      moment.justUseJalali = false;
    };
    jMoment.jDaysInMonth = function(year, month) {
      year += div(month, 12);
      month = mod(month, 12);
      if (month < 0) {
        month += 12;
        year -= 1;
      }
      if (month < 6) {
        return 31;
      } else if (month < 11) {
        return 30;
      } else if (jMoment.jIsLeapYear(year)) {
        return 30;
      } else {
        return 29;
      }
    };
    jMoment.jIsLeapYear = isLeapJalaliYear;
    moment.updateLocale("fa", {
      months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
      monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
      weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
      weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
      weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        L: "jYYYY/jMM/jDD",
        LL: "jD jMMMM jYYYY",
        LLL: "jD jMMMM jYYYY LT",
        LLLL: "dddd، jD jMMMM jYYYY LT"
      },
      calendar: {
        sameDay: "[امروز ساعت] LT",
        nextDay: "[فردا ساعت] LT",
        nextWeek: "dddd [ساعت] LT",
        lastDay: "[دیروز ساعت] LT",
        lastWeek: "dddd [ی پیش ساعت] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "در %s",
        past: "%s پیش",
        s: "چند ثانیه",
        m: "1 دقیقه",
        mm: "%d دقیقه",
        h: "1 ساعت",
        hh: "%d ساعت",
        d: "1 روز",
        dd: "%d روز",
        M: "1 ماه",
        MM: "%d ماه",
        y: "1 سال",
        yy: "%d سال"
      },
      ordinal: "%dم",
      preparse: function(string) {
        return string;
      },
      postformat: function(string) {
        return string;
      },
      week: {
        dow: 6,
        doy: 12
        // The week that contains Jan 1st is the first week of the year.
      },
      meridiem: function(hour) {
        return hour < 12 ? "ق.ظ" : "ب.ظ";
      },
      jMonths: "فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند".split("_"),
      jMonthsShort: "فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند".split("_")
    });
    jMoment.bindCalendarSystemAndLocale();
    moment.locale("en");
    jMoment.jConvert = {
      toJalali,
      toGregorian
    };
    function toJalali(gy, gm, gd) {
      var j = convertToJalali(gy, gm + 1, gd);
      j.jm -= 1;
      return j;
    }
    function toGregorian(jy, jm, jd) {
      var g = convertToGregorian(jy, jm + 1, jd);
      g.gm -= 1;
      return g;
    }
    function div(a, b) {
      return ~~(a / b);
    }
    function mod(a, b) {
      return a - ~~(a / b) * b;
    }
    function convertToJalali(gy, gm, gd) {
      if (Object.prototype.toString.call(gy) === "[object Date]") {
        gd = gy.getDate();
        gm = gy.getMonth() + 1;
        gy = gy.getFullYear();
      }
      return d2j(g2d(gy, gm, gd));
    }
    function convertToGregorian(jy, jm, jd) {
      return d2g(j2d(jy, jm, jd));
    }
    function isLeapJalaliYear(jy) {
      return jalCal(jy).leap === 0;
    }
    function jalCal(jy) {
      var breaks = [
        -61,
        9,
        38,
        199,
        426,
        686,
        756,
        818,
        1111,
        1181,
        1210,
        1635,
        2060,
        2097,
        2192,
        2262,
        2324,
        2394,
        2456,
        3178
      ], bl = breaks.length, gy = jy + 621, leapJ = -14, jp = breaks[0], jm, jump, leap, leapG, march, n, i;
      if (jy < jp || jy >= breaks[bl - 1])
        throw new Error("Invalid Jalali year " + jy);
      for (i = 1; i < bl; i += 1) {
        jm = breaks[i];
        jump = jm - jp;
        if (jy < jm)
          break;
        leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
        jp = jm;
      }
      n = jy - jp;
      leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
      if (mod(jump, 33) === 4 && jump - n === 4)
        leapJ += 1;
      leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;
      march = 20 + leapJ - leapG;
      if (jump - n < 6)
        n = n - jump + div(jump + 4, 33) * 33;
      leap = mod(mod(n + 1, 33) - 1, 4);
      if (leap === -1) {
        leap = 4;
      }
      return {
        leap,
        gy,
        march
      };
    }
    function j2d(jy, jm, jd) {
      var r = jalCal(jy);
      return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
    }
    function d2j(jdn) {
      var gy = d2g(jdn).gy, jy = gy - 621, r = jalCal(jy), jdn1f = g2d(gy, 3, r.march), jd, jm, k;
      k = jdn - jdn1f;
      if (k >= 0) {
        if (k <= 185) {
          jm = 1 + div(k, 31);
          jd = mod(k, 31) + 1;
          return {
            jy,
            jm,
            jd
          };
        } else {
          k -= 186;
        }
      } else {
        jy -= 1;
        k += 179;
        if (r.leap === 1)
          k += 1;
      }
      jm = 7 + div(k, 30);
      jd = mod(k, 30) + 1;
      return {
        jy,
        jm,
        jd
      };
    }
    function g2d(gy, gm, gd) {
      var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;
      d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
      return d;
    }
    function d2g(jdn) {
      var j, i, gd, gm, gy;
      j = 4 * jdn + 139361631;
      j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
      i = div(mod(j, 1461), 4) * 5 + 308;
      gd = div(mod(i, 153), 5) + 1;
      gm = mod(div(i, 153), 12) + 1;
      gy = div(j, 1461) - 100100 + div(8 - gm, 6);
      return {
        gy,
        gm,
        gd
      };
    }
  }
});
export default require_jalali_moment();
/*! Bundled license information:

moment/locale/fa.js:
  (*! moment.js locale configuration *)
  (*! locale : Persian [fa] *)
  (*! author : Ebrahim Byagowi : https://github.com/ebraminio *)
*/
//# sourceMappingURL=jalali-moment.js.map
